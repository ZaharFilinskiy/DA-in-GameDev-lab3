# АНАЛИЗ ДАННЫХ И ИСКУССТВЕННЫЙ ИНТЕЛЛЕКТ [in GameDev]
Отчет по лабораторной работе #3 выполнил(а):
- Филинский Захар Евгеньевич
- РИ211121
Отметка о выполнении заданий (заполняется студентом):

| Задание | Выполнение | Баллы |
| ------ | ------ | ------ |
| Задание 1 | * | 60 |
| Задание 2 | * | 20 |
| Задание 3 | # | 20 |

знак "*" - задание выполнено; знак "#" - задание не выполнено;

Работу проверили:
- к.т.н., доцент Денисов Д.В.
- к.э.н., доцент Панов М.А.
- ст. преп., Фадеев В.О.

[![N|Solid](https://cldup.com/dTxpPi9lDf.thumb.png)](https://nodesource.com/products/nsolid)

[![Build Status](https://travis-ci.org/joemccann/dillinger.svg?branch=master)](https://travis-ci.org/joemccann/dillinger)

Структура отчета

- Данные о работе: название работы, фио, группа, выполненные задания.
- Цель работы.
- Задание 1.
- Код реализации выполнения задания. Визуализация результатов выполнения (если применимо).
- Задание 2.
- Код реализации выполнения задания. Визуализация результатов выполнения (если применимо).
- Задание 3.
- Код реализации выполнения задания. Визуализация результатов выполнения (если применимо).
- Выводы.
- ✨Magic ✨

## Цель работы
Познакомиться с программными средствами для создания системы машинного обучения и ее интеграции в Unity.

## Задание 1
### Реализовать систему машинного обучения в связке Python - Google-Sheets – Unity. При выполнении задания можно использовать видео-материалы и исходные данные, предоставленные преподавателями курса.

Ход работы: Работа над заданием началась с повторения настройки программ, с видео из методических указаний, но по мере углубления в процесс пришлось читать доп.информацию и находить ответы самому. Поэтому, лишь проанализировав действия, удалось усвоить информацию.

-Выполнив каждый ход работы, от связи Unity с MlAgent:

![2022-11-05_19-37-17](https://user-images.githubusercontent.com/114186148/200125153-37d1b9e3-8f50-4232-bbf1-8a41f01c3565.png)

-До обучения объекта через anaconda promt и добавления обьектов:

![2022-11-05_19-43-17](https://user-images.githubusercontent.com/114186148/200125417-d779bfb0-976c-43db-8aff-03ff13a304d2.png)

-Мне удалось понять принцип работы с обучаемой системой в unity, поближе познакомиться с данным способом работы в игровой индустрии и собственноручно, много раз, "натренировать" нейросеть:

![2022-11-05_19-48-33](https://user-images.githubusercontent.com/114186148/200125677-c18b3b80-bd08-42fc-95c6-b41296a7e6ed.png)

![2022-11-05_19-49-43](https://user-images.githubusercontent.com/114186148/200125748-4429dfa3-ba72-4ef0-881c-755b5663d2d8.png)

-Также для себя я подметил некоторые интересные моменты, которые влияют на работу всей системы. Оказывается для полноценного машинного обучения важно иметь совместимые версии программ, работающих между собой, уделять внимание правильной настройке компонентов, таких как обьекты и програмный код и больше читать. Потому-что знаний мало, а сделать хочется много.

## Задание 2
### Подробно опишите каждую строку файла конфигурации нейронной сети, доступного в папке с файлами проекта по ссылке. Самостоятельно найдите информацию о компонентах Decision Requester, Behavior Parameters, добавленных на сфере.

trainer_type – задаёт тип используемого для обучения тренажёра (PPO или SAC)

batch_size – Количество опытов на каждой итерации градиентного спуска.

buffer_size – Количество опыта, которое нужно собрать для обновления итерации или её изучения.

learning_rate – изменение скорости обучения модели с течением времени.

beta – исследование случайных (более или менее) пространств действий.

epsilon – параметр влияющий на быстроту развития (ускорения работы) системы с каждой итерацией.

lambd – параметр оценивающий совпадение стоимости вознаграждения обучений между собой (что то вроде погрешности), чем стабильнее значения. тем быстрее идёт процесс.

num_epoch – Количество проходов через буфер опыта при выполнении оптимизации градиентного спуска. (чем больше, тем быстрее итерация и наоборот)

learning_rate_schedule – скорость обучения, которая в нашем случае уменьшается линейно до нуля.

normalize – отвечает за то будут ли нормироваться (усредняться) входные данные (в нашем случае -нет)

hidden_units – количество значений в подключенном слое нейронной сети (то есть чем больше будет поток входных данных, тем больше нужно ввести значения параметра и наоборот).

num_layers – Количество скрытых слоев в нейронной сети. Число слоёв, принимающих на себя работу, чем сложнее задача, тем больше нужно слоёв.

gamma – Параметр, отвечающий за то, насколько далеко вперёд должен думать о вознаграждении агент. Должен быть в состоянии подготовиться – выделить объём места и т.д. 

strength – Коэффициент, на который умножается вознаграждение, предоставляемое средой. Благодаря этому параметру можно увеличивать или уменьшать количество поступаемой валюты.

max_steps – Общее количество шагов-действий, которые должны быть выполнены в среде до завершения процесса обучения.

time_horizon – Сколько опыта нужно собрать перед тем, как добавить в буфер. Также используется, как среднее значение для общего ожидаемого вознаграждения.

summary_freq – Количество опыта, которое необходимо собрать перед созданием и отображением статистики обучения.

hyperparameters – Группировка параметров, отвечающих за управления процессом обучения

network_settings – Группировка параметров, отвечающих за обучение сети.

reward_signals – Раздел позволяющий задавать настройки как для внешних, так и для внутренних сигналов вознаграждения.

extrinsic – внешний сигнал из reward_signals

## Задание 3
### Должна ли величина loss стремиться к нулю при изменении исходных данных? Ответьте на вопрос, приведите пример выполнения кода, который подтверждает ваш ответ.Какова роль параметра Lr? Ответьте на вопрос, приведите пример выполнения кода, который подтверждает ваш ответ. В качестве эксперимента можете изменить значение параметра.

-Опытным путём я установил что ведечина loss не должна стремиться к нулю при изменении исходных данных. Если loss будет стремиться к нулю то график будет паралельным оси x или же острым углом к этой же оси. 

```py
a = np.random.rand (1)
print(a)
b = np.random.rand(1)
print (b)
Lr = 0.000001

a,b = iterate(a,b,x,y,1)
prediction=model (a, b, x)
loss = 0
print (a, b, loss)
plt.scatter(x, y)
plt.plot(x,prediction)

```
Итог : https://github.com/ZaharFilinskiy/DA-in-GameDev-lab1/blob/ea2c933e63cf9cbc5a1718a1495bfee4f18708dc/2022-09-26_19-29-03.png

-Параметр Lr помогает правильно выстравить кривую и соотвествущие ей оси x и y. Выступает в роли некого коэффициента, домножая на который система координат xy выстраивается в нужное положение.

```py
a = np.random.rand (1)
print(a)
b = np.random.rand(1)
print (b)
Lr = 0.01

a,b = iterate(a,b,x,y,1)
prediction=model (a, b, x)
loss = loss_function(a, b, x, y)
print (a, b, loss)
plt.scatter(x, y)
plt.plot(x,prediction)
```

-Пример что будет если изменить коэффициент: https://github.com/ZaharFilinskiy/DA-in-GameDev-lab1/blob/fabc8f2eba84418b48e07a94a3c5d635a6ba6724/2022-09-26_19-40-57.png

## Выводы

В ходе выполнения данной лабораторной работы я разобрался с установкой необходимого ПО и также смог настроить его. Написал свою первую программу на unity, anacondaz и поближе познакомился с интерфейсом и функционалом программ. Помимо этого, глубже изучил понятие линейной регрессии на языке python.

## Powered by

**BigDigital Team: Denisov | Fadeev | Panov**
